  # SincronizaciÓn PID lazo abierto

## 1. Introducción 

El diseño de controladores es fundamental en la ingeniería de control para automatizar procesos y hacerlos funcionar correcta y eficientemente. Uno de los métodos de esta área de estudio es diseñar controladores de tipo PID (Proporcional, integral y derivativo), debido a su sencilles y efectividad que mejora el comportamiento de nuestros sistemas. Los controladores tienen dos formas de funcionar, las cuales son con retroalimentación (Lazo cerrado) y sin retroalimentación (Lazo abierto). Cuando hablados de diseño de controladores en lazo abierto, nos referimos a cuando el controlador hace su trabajo sin tener en cuenta la retroalimentación del sistema durante su proceso. La sincronización PID en lazo abierto nos permite calcular varios de los parámetros de forma más directa, aprovechando herramientas tales como frecuencia, ubicación de polos o ajustes en base al comportamiento deseado.

En la clase se explicaron fundamentos del PID por cada una de sus partes, y como en base a cada uno de sus componentes nuestro sistema va a variar, como por ejemplo en nuestro tiempo de respuesta, oscilaciones, estabilidad y en el error estacionario; así como se describieron las ventajas y desventajas que se pueden presentar al usar este método de sincronización. En el siguiente resumen se explicará el tema trabajado en la clase de sincronización de PID en lazo abierto describiendo las acciones del controlador, sus tipos de arquitectura, como lograr la sincronización en lazo abierto y algunos de los métodos para probar esto.


## 2. Acciones de control

### 2.1. Acción proporcional

La acción proporcional se llama así, debido a que esta es proporcional a la señal del error. Esta multiplica nuestra señal del error por una ganancia Kp que determina cuanta será esta acción del controlador, por lo que podemos inferir que esta es útil cuando se tiene un solo error en el sistema. Como es una multiplicación la ecuación que representa lo que pasa en la acción proporcional es la siguiente:

$$u(t) = Kp * e(t)$$
$$U(S) = Kp * E(S)$$

Cuando aumentamos la acción proporcional nos ocurrirá lo siguiente:

- Aumenta la velocidad del sistema
- Disminuye el error del sistema
- El sistema se vuelve más inestable

### 2.2. Acción integral 

La acción integral se puede describir como la suma o acumulación de la señal del error; esto debido a que toma esta señal y la integra para que mientras se observa el sistema con esta acción después de un tiempo se podrán ver pequeños errores que se sumaran haciendo que la acción integral sea mayor. Por lo tanto, si nuestro error tiende a cero esta acción lo disminuye cada vez más, hasta que llegue a cero. Por lo que las fórmulas son las siguientes:

$$u(t) = K_{i} \int  e(t)dt$$
$$U(S) = K_{i} * \frac{E(S)}{S}$$


Cuando aumentamos la acción integral pasar lo siguiente:

- Disminuye el error en régimen permanente
- Aumenta la velocidad del sistema
- El sistema se vuelve más inestable


### 2.3. Acción derivativa 

La acción derivativa es proporcional a la derivada de la señal del error, por lo que tendremos una ganancia Kd que multiplicaremos por el error para poder disminuir las variaciones del error en el sistema. Como es una multiplicación la fórmula es la siguiente:

$$u(t) = K_{d} * \frac{de(t)}{dt}$$
$$U(S) = K_{d} * sE(S)$$

![](Imagenes/CurvaDerivativa.PNG).

Figura 1. Grafica curva accion derivativa

Aumentar la constante derivativa tiene los siguientes efectos en el sistema:

- Aumenta la estabilidad del sistema
- El error en régimen permanente funciona igual
- Disminuye la velocidad del sistema


## 3. Arquitecturas PID

La arquitectura PID es aquella que nos permite combinar de diferentes maneras las acciones de control (Proporcional, Integral y Derivativa). A continuación se verán las 3 arquitecturas clásicas.

![](Imagenes/DBControladorPID.PNG).

Figura 2. Diagrama de bloques controlador PID.

### 3.1. Arquitectura paralela 

Lo que se hace en la arquitectura paralela es tomar nuestra tres acciones de control, sumarlas directamente y multiplicarlas por el error, para después sumar nuestro controlador PID a nuestra función de transferencia para estabilizar el sistema.

$$U(S) = Kp * E(S) + K_{i} * \frac{E(S)}{S} +  K_{d} * sE(S)$$
$$u(t) = Kp * e(t) + K_{i} \int  e(t)dt + K_{d} * \frac{de(t)}{dt}$$

![](Imagenes/ArquitecturaP.PNG).

Figura 3. Arquitectura paralela circuito. 

### 3.2. Arquitectura ideal

En la arquitectura ideal lo que se hace es multiplicar el error por la suma de nuestras acciones integral y derivativa, para despues multiplicar esta señal por nuestra accion proporcional. Esto se hace por que al multiplicar nuestro error por nuestra accion proporcional se vuelve muy grande, por lo que al mutiplicarlo primero por las otras dos acciones este se vuelve menos significativo.

$$U(s) = Kp * (E(s) + \frac{1}{Ti} * \frac{E(s)}{s} + Td * s * E(s))$$
$$u(t) = Kp * (e(t) + \frac{1}{Ti} * \int e(t)dt + Td\frac{de(t)}{dt} )$$

![](Imagenes/ArquitecturaI.PNG).

Figura 4. Arquitectura ideal circuito.

### 3.3. Arquitectura serie

La arquitectura en serie es la es la que mejor funciona cuando queremos hacer un control PID, pero por lo mismo es la más compleja de todas. Esta pasa primero por la acción derivativa, para después multiplicarla por la acción derivativa y la acción integral después de pasar por el diagrama de bloques como se muestra en la figura 6

$$U(s) = ((E(s)(1 + Td * s))Kp)(1 + \frac{1}{Ti * s})$$
$$u(t) = \frac{1}{Ti} \int ((e(t) + Td\frac{de(t)}{dt})Kp)dt$$

![](Imagenes/ArquitecturaS.PNG).

Figura 5. Arquitectura serie circuito 

## 4. Sincronización por prueba y error

La sincronizacion por prueba y error se hace para ajustar las ganancias (Kp, Ki, Kd) para obtener la respuesta que se necesite. La metodologia que se suele utilizar es la siguiente:

- Ajustamos las ganancias Ki y Kd a cero.
- Aumentamos la ganancia Kp hasta tener el tiempo de establecimiento anhelado.
- Aumentamos Ki hasta tener el sobreimpulso anhelado.
- Aumentamos Kd hasta reducir las oscilaciones al comportamiento anhelado.
- Volvemos a ajustar la ganancia proporcional Kp.
- Ajustar las demás ganancias para que funcione óptimamente el sistema.


## 5. Criterio de desempeño 

### 5.1. Funciones de costo mas utilizadas

Son las que ayudan a saber que tan bien sintonizado esta el error, estos me permiten saber que cambios hace el controlador. Estas son las pruebas mas comunes.

- IE = Integral del error = Se integra para saber que tan bueno él es controlador = $\int e(t)dt$
- ISE = Integral del error al cuadrado = Se utiliza para solo tener valores positivos = $\int e(t)^{2}dt$
- IAE = Integral del error absoluto = Se utiliza cuando hay valore muy pequeños que al elevarlos al cuadrado tienden a cero  = $\int |e(t)|dt$
- ITAE = Integral del error absoluto por el tiempo = Es para cuando el error no disminuye rápidamente. = $\int |e(t) * t|dt$

![](Imagenes/IntegralError.PNG).

Figura 6. Graficas integrales del error.

### 5.2. Criterio de sintonización por optimización 

Estas metodologías buscan minimizar algunos índices de desempeño, utilizando los métodos vistos anteriormente. Esto con variaciones en los parámetros para obtener una función de costo que nos permita encontrar un óptimo ideal. 

$$L(t) = f(\int e(t), t)$$

![](Imagenes/Optimo.PNG).

Figura 7. Grafica optimo


## 6. Métodos de sincronización

### 6.1. Método de Ziegler & Nichols

Este es el primer metodo que se vio en clase, para la sintonizacion de controladores PID en lazo abierto. Este metodo utiliza parametros de primer orden mas tiempo muerto que se obtienen en las curvas de reaccion.
Este metodo nos garantiza que la segunda oscilacion de la respuesta sea 1/4 del maximo pico. 


|Tipo de controlador   | $k_{p}$  | $T_{i}$  | $T_{d}$  |
|---|---|---|---|
| P  | $\frac{\tau}{t_{o}K}$  | ---  | ---  |
| PI  | $\frac{0.9\tau}{t_{o}K}$  | $3.3t_{o}$  | ---  |
| PID  | $\frac{0.9\tau}{t_{o}K}$   | $2t_{o}$  | $0.5t_{o}$  |


![](Imagenes/Perturbacionuncuarto.PNG).

Figura 8. Caida de la respuesta ante perturbaciones

![](Imagenes/CambioReferencia.PNG).

Figura 9. Caida de la respuesta ante cambios en la referencia

Podemos observar en las imágenes que ante distintas circunstancias, cuando aplicamos el método de Ziegler y Nichols la curva de reacción será la esperada, en donde su segunda oscilación será un cuarto de la primera.


### 6.2. Método de Cohen-coon

El segundo método de sintonización en PID de lazo abierto que se explicó en la clase es el de cohen-Coon, el cual tiene algunas similitudes con el de Ziegler y Nichols en cuando a las ganancias integral y derivativas en el PID.

Por lo tanto, al igual que en el método anterior la segunda oscilación también será de un cuarto de la primera, y además tendremos un sobre impulso y área bajo la curva muy reducidas

| Tipo de controlador  | $k_{p}$  | $T_{i}$  | $T_{d}$  |
|---|---|---|---|
| P   | $\frac{1}{K} * \frac{\tau }{t_{o}} * (\frac{3\tau + t_{o}}{3\tau})$  | ---  | ---  |
| PI   | $\frac{1}{K} * \frac{\tau }{t_{o}} * (\frac{10.8\tau + t_{o}}{12\tau})$  | $(\frac{30 + 3(\frac{t_{0}}{\tau })}{9 + 20(\frac{t}{\tau })}) * \tau $  | ---  |
| PID   | $\frac{1}{K} * \frac{\tau }{t_{o}} * (\frac{16\tau + 3t_{o}}{12\tau})$  | $2t_{o}$  | $0.5t_{o}$  |


### 6.3. Método de coeficiente de ajustabilidad



| y  | $k_{p}$  | $T_{i}$  | $T_{d}$  |
|---|---|---|---|
| 0 a 0.1  | $\frac{5}{K}$  | $\tau$  | ---  |
| 0.1 a 0.2  | $\frac{0.5}{K_{y}}$  | $\tau$  | ---  |
| 0.2 a 0.5  | $\frac{0.5(1 + 0.5_{y})}{K_{y}}$  | $\tau(1 + 0.5_{y})$  | $\tau * \frac{0.5_{y}}{0.5_{y} + 1}$  |


### 6.4. Método Smith (PID)



![](Imagenes/MSmithPI.PNG).

Figura 10.Metodo Smith PI

![](Imagenes/MSmithPID.PNG).

Figura 11.Metodo Smith PID

## 7. Ejercicios 




## 8. Síntesis conclusiva.

## 9. Referencias

- Ajuste empírico controladores PID. F Morilla. Dpto. Informatica y Automática, UNED, 2006
- Handbook of PI and PID controller Tuning Rules, Aidan O’Dwyer, 3d edition, 2009
- Analog & Digital Control Systems Design. Chi Tsong Chen. State University of New York. New York
- Principles and practice of automatic process control. Smith. C. and A. Corripio. 2 Edition. Jhon Wiley & Sons Editorial
